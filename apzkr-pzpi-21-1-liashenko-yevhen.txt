Міністерство освіти та науки України Харківський національний університет радіоелектроніки



Кафедра програмної інженерії


КУРСОВА РОБОТА ПОЯСНЮВАЛЬНА ЗАПИСКА
з дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Програмна система для управління та обліку кількості використаних енергоресурсів в лоукост готелях»


Виконав
ст. гр. ПЗПІ-21-1



Ляшенко Є. А.

Керівник: доц. каф. ПІ




Лещинський В. О.

Робота захищена на оцінку





Комісія: доц. каф. ПІ





Лещинський В. О.
доц. каф. ПІ
ст. викл. каф. ПІ


Лещинська І. О. Сокорчук І. П.





Харків 2024





Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Ляшенку Євгену Андрійовичу
Тема роботи: «Програмна система для управління та обліку	кількості використаних енергоресурсів в лоукост готелях»	
Термін узгодження завдання курсової роботи «1» квітня 2024 р.
Термін здачі студентом закінченої роботи «27» червня 2024 р.
Вихідні дані до проекту (роботи): В програмній системі передбачити:
реалізація двох компонентів (Back-end, IoT), унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, локалізація, забезпечення конфіденційності та адміністрування системи	
Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram	

КАЛЕНДАРНИЙ ПЛАН



Номер
Назва етапів курсової роботи
Строк виконання
етапів роботи
Примітки
1
Функціональна специфікація
програмного проекту
31.03.24


2
Проектування програмного
проєкту
30.04.24


3
Кодування програмного проекту
20.05.24


4
Оформлення пояснювальної
записки
31.05.24


5
Захист курсової роботи
08.06.24




Дата видачі завдання «1» квітня 2024 р.

Керівник


Завдання прийняв до виконання ст. гр. ПЗПІ-21-1
 		
доц. Лещинський В.О. (підпис)


Ляшенко Є.А.
(підпис)

РЕФЕРАТ


Пояснювальна записка до курсової роботи: 55 с., 10 рис., 2 табл. 3 додатки, 4 джерела.
ВІДВІДУВАЧІ, КІМНАТИ, РЕСУРСИ, ДАТЧИК, МАНДРІВНИКИ, ЕНЕРГОРЕСУРСИ, ПРОГРАМНА СИСТЕМА, КОРИСТУВАЧ, КЛІЄНТ.
Об’єктом дослідження є галузь готельного бізнесу, з фокусом на створенні програмної системи для готелів, що використовує технології IoT.
Метою курсової роботи є розробка програмної системи, яка автоматично підраховує кількість використаних енергоресурсів. Система дозволяє адміністраторам та користувачам в режимі реального часу спостерігати та відстежувати кількість використаних ресурсів та сповіщати про критичне їх використання.
Технічна реалізація базується на ASP.NET Web API та мові програмування C#, з використанням бази даних MSSQL Server. Для інтеграції з IoT-пристроями використовуються відповідні серверні рішення.
У результаті роботи була розроблена програмна система для відстеження кількості використаних ресурсів в сучасних готелях. Вона включає серверну частину для обробки даних та сервер для інтеграції з IoT-пристроями.

ЗМІСТ



Вступ	7
1 Аналіз предметної області	8
    1.1 Бізнес-вимоги	8
        1.1.1 Бізнес-можливості	8
        1.1.2 Бізнес-цілі та критерії успіху	9
        1.1.3 Потреби клієнтів або ринку	10
        1.1.4 Бізнес-ризики	11
    1.2 Концепція рішення	12
        1.2.1 Окреслення концепції	12
        1.2.2 Головна функціональність	13
        1.2.3 Припущення та залежності	15
    1.3 Рамки та обмеження проекту	16
        1.3.1 Рамки первинного випуску	16
        1.3.2 Рамки наступних випусків	19
        1.3.3 Обмеження та винятки	20
    1.4 Бізнес-контекст	21
        1.4.1 Профілі зацікавлених сторін	21
        1.4.2 Пріоритети проекту	22
        1.4.3 Робоче середовище	23
2 Постановка задачі	25
3 Проектування бази даних	26
    3.1 Побудова ER-діаграми	26
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	28
4 Архітектура програмної системи	31
    4.1 Архітектура серверної частини	31
    4.2 Архітектура IoT частини	35
5 Опис програмної системи	39
    5.1 Виклик і завантаження	39
    5.2 Призначення і логічна структура	40	
Висновки	42
Перелік джерел посилання	43
Додаток А Результат перевірки на плагіат	44
Додаток Б Програмний код серверної частини	45
Додаток В Програмний код IoT пристрою	53




ВСТУП




У наші часи подорожувати стає все легше та доступніше. Кожен має хоча б одне місце, де хотів би побувати протягом свого життя. Але, на жаль, далеко не всі можуть собі це дозволити. Більшість готелів не відповідають тим вимогам, за які платяться гроші та це є великою проблемою при подорожуванні. Попри розвиненість готельного бізнесу, саме в цьому контексті виникає потреба в розробці інноваційного рішення, яке могло б зробити туризм доступнішим та дешевшим.
Система, яку ми пропонуємо, вирішує ці проблеми за допомогою функціонального програмного забезпечення, що включає в себе найкращі та найновіші технології для обробки даних та контролю використаних ресурсів за час проживанні в номері. Передові IoT девайси допомагають якісно та швидко проводити обробку зібраної інформації та надсилати дані прямо до менеджерів, які вже будуть ними оперувати.
Цей продукт є великим рухом вперед у розвитку туризму та може дуже легко та якісно вивести цю сферу на новий рівень, дозволяючи менеджерам легко розраховувати реальну ціну за оренду житла, а мандрівникам обирати найкращі та найвигідніші варіанти у кожному куточку світу. Це є найкращим доказом нашої відданості розвитку цієї сфери та розробки найкращого рішення цієї проблеми.

АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ

Бізнес-вимоги
Бізнес-можливості



Аналоги:

Sonder: Ця компанія пропонує апартаменти з обслуговуванням у виді готелю. Для зручності, вони використовують технології для персоналізації інформації перебування своїх гостей. Але, по-перше, дані послуги доступні лише в обмежених містах, по-друге, низький рівень відношення ціна-послуги, а також Sonder звинувачували в тому, що вони не пропонують достатньо зручностей та послуг.
OYO Rooms: Ця індійська мережа пропонує житло в готелях та хостелах за відносно низьку ціну. Також вони використовують достатньо нові технології для менеджменту клієнтів та бронювань. Попри це, якість обслуговування залишає очікувати кращого, а саму компанію звинувачували в дуже поганій організації даних та витоку інформації клієнтів до мережі.
Airbnb: Ця онлайн платформа дозволяє людям орендувати та здавати житло в оренду по всьому світу. Вони пропонують широкий спектр житла, а також велику кількість послуг. Незважаючи на це, з часом стає дуже важко знайти надійних орендарів та орендодавців, а Airbnb може створювати проблеми для місцевих жителів, призводячи до зростання орендної плати та джентрифікації.

Даний продукт спрямований на ринок готелів, аби вивести його на новий рівень та повністю змінити існуючу концепцію плати за зняття кімнат. Основний спосіб монетизації полягає у співпраці з готелями та сервісами зі здачі апартаментів в оренду, надаючи їм зручний та ефективний інструмент для найкращого та найефективнішого розрахунку ціни за житло.




Бізнес-цілі та критерії успіху




БЦ-1: Зручний моніторинг для покращення досвіду адміністраторів та відвідувачів готелів:
БЦ-1.1: Розробити інтерфейс для збору даних витрачених ресурсів у реальному часі (кількість витраченої води, електроенергії, світла та калькуляція поточної ціни за витрати) та інтеграція з іншими системами.
БЦ-1.2: Розробити інтуїтивний веб- та мобільний інтерфейс для готелів та відвідувачів з легким доступом до даних, управління датчиками та звітами


КУ-1: Досягти 90% задоволеності користувачів:

КУ-1.1: Проводити регулярні опитування адміністраторів, менеджерів та відвідувачів готелів для збору відгуків про систему



БЦ-2: Підвищити ефективність та прозорість підрахунку ціни, яку платить відвідувач за оренду кімнати:

БЦ-2.1: Оптимізація обробки даних для швидкого та точного аналізу використаних ресурсів за час перебування в готелі.
БЦ-2.2: Поліпшити користувацький доступ для відвідувачів з доступом до комплексних даних з використаних ресурсів, покращуючи досвід користувача.


КУ-2: Успішність використання продукту:

КУ-2.1: Скорочення часу обробки даних та підвищення їх ефективності. КУ-2.2: Інтеграція з існуючими готелями та хостелами (не менше 60%).


БЦ-3: Розширення користувацької бази:

БЦ-3.1: Збільшення користувачів на 20% за 3 місяці завдяки стратегічній маркетинговій кампанії, спрямовану на готелі, які потребують розширення та відвідувачів.


КУ-3: Ефективність та успішність системи

КУ-3.1: Точність аналізу та передачі даних користувачів (не менше 90%).

КУ-3.2: Безперебійна робота системи оповіщення, якщо рівень використаних ресурсів перебільшує зазначену норму





Потреби клієнтів або ринку


Через докладні дослідження ринку цей проект виявив критичні потреби та проблеми клієнтів у сфері готельного бізнесу, що призвели до розробки програмного продукту. Ці потреби включають:
П-1: Моніторинг адміністраторами використання енергоресурсів відвідувачів. Адміністратори та відвідувачі потребують можливості регулярного відстеження кількості витрачених води, світла та електроенергії 11 та тепла. Це дає їм комплексне уявлення про використані ресурси та їх кількість, що дає змогу реально розрахувати ціну за оплату житла та попередити відвідувача у разі реальної потреби.
П-2: Інтеграція та інтуїтивний інтерфейс. Користувачі шукають систему, яка легко інтегрується з IoT-пристроями та готелями. Інтерфейс користувача повинен бути простим і зрозумілим, щоб адміністратори, менеджери та відвідувачі могли легко та зрозуміло отримати потрібні інформацію та звіти.
П-3: Система екстреного оповіщення. Готелі потребують системи, яка автоматично сповіщає адміністраторів у випадках надмірного використання ресурсів, аби запобігти пожежі або потопу. Це гарантує, що адміністратор негайно сповістить відвідувача та викличе відповідні спецслужби, якщо це потрібно.
П-4: Співпраця між адміністратора готелю та відвідувачами. Система повинна сприяти ефективній комунікації між готельним персоналом та мандрівниками. Це дає можливість відвідувачам бути в курсі кількості витрачених ресурсів та ціни, яку вони заплатять при виїзді.
П-5: Аналітика та дослідження. Система повинна генерувати аналітичні дані на основі використаних, користувачем, ресурсів. Це дає цінну інформацію для розрахунку ціни при виселенні.


Бізнес-ризики
Конкуренція: існує загроза конкуренції з боку інших компаній, які розробляють подібні системи для кращого розрахунку ціни та використаних енергоресурсів за час перебування в готелі.
Дії: Розробка унікальної пропозиції продажу, яка підкреслює переваги та інновації системи.
Технічні проблеми: несправності датчиків або відмови системи можуть призвести до неточного розрахунку фінальної ціни за оплату житла.
Дії: використовувати високоякісні датчики та компоненти від надійних постачальників, проводити ретельні тести та перевірки системи на всіх етапах розробки, забезпечити надійну систему резервного копіювання.
Низька прийнятність ринку: недостатня обізнаність про продукт або низька зацікавленість з боку установ готельного бізнесу можуть обмежити його прийняття.
Дії: провести ефективну маркетингову кампанію, спрямовану на готельний бізнес та мандрівників, співпрацювати з ключовими лідерами думок та готельними організаціями, продемонструвати ефективність системи за допомогою досліджень та реальних випадків використання.


Концепція рішення

Окреселення концепції

Концепція передбачає створення інноваційної програмної системи для точного розрахунку використаних енергоресурсів в готелях, яка трансформує підхід до моніторингу та управління використання цих ресурсів в готелях та хостелах. Мета полягає в тому, щоб розробити високоточну, доступну та просту у використанні систему, яка дозволить працівникам готелів та відвідувачів проводити потрібний моніторинг використання ресурсів та вчасно запобігти підвищенню дозволеного рівня використання ресурсів та критичних ситуацій.
Після впровадження системи моніторингу очікується зміна підходу до надання готельних послуг. Система дозволить менеджерам та адміністраторам готелів слідкувати за споживанням ресурсів,отримувати та аналізувати актуальні дані, рахувати ціну за перебування у готелі та попереджати відвідувачів про можливу екстрену ситуацію в разі потреби. Це дозволить запобігти надмірному споживанню енергоресурсів та екстренним ситуаціям. Також, відвідувачі можуть контролювати та бачити, скільки ресурсів вони використали та зробити відповідні висновки з майбутнього використання.
Ця концепція ґрунтується на інноваційній ідеї, яка може залучу багато мандрівників, які залюбки полюбляєте подорожувати та любити це бюджетно. Метою є створення продукту, який допоможе змінити парадигму розрахування цін на житло, зробивши його більш доступним, надійним та зручним для всіх зацікавлених сторін.




Головна функціональність




MF-1: Реєстрація та авторизація користувачів у мобільному додатку та веб-інтерфейсі.
MF-2: Збір та моніторинг використаних енергоресурсів, включаючи кількість води, світла та електроенергії. Дані з датчиків будуть моніторитися цілодобово, дозволяючи обом зацікавленим сторонам слідкувати за актуальними даними та зробити потрібну аналітику.
MF-3: Додавання нових кімнат в готелі до системи за допомогою адміністративної панелі. Під час додавання можна буде налаштувати датчики для збору необхідної інформації.
MF-4: Автоматичне сповіщення адміністраторів готелю про надмірну та, можливе, небезпечну кількість використаних ресурсів за короткий проміжок часу. Це дозволить завчасно уникнути критичної ситуації та прийняти необхідні міри.
MF-5: Перегляд даних реальний стан кімнати та аналізів, збережених у адміністративній панелі веб-сайту, за допомогою мобільного додатку.
MF-6: Можливість адміністраторів управляти датчиками, які знаходяться в різних кімнатах, через адміністративну панель веб-сайту.
MF-7: Віддалений перегляд та аналіз історії використаних ресурсів відвідувачем через мобільний додаток або веб-інтерфейс.
MF-8: Технічна підтримка для користувачів яка допоможе вирішити будь-які технічних питання та надасть потрібні поради щодо використання системи.

Припущення та залежності




Припущення:
Припускається, що система повинна мати доступ до необхідних датчиків для збору кількості використаних енергоресурсів, таких як вода, світло та електроенергія. Ці датчики повинні бути сумісними з системою та відповідати вимогам щодо точності та надійності.
Припускається, що користувачі матимуть доступ до мобільних пристроїв, необхідних для використання мобільного додатку системи. Ці пристрої повинні мати можливість підключатися до Інтернету та мати сумісні з системою операційні системи.
Припускається, що стабільний доступ до Інтернету буде забезпечений для передачі даних між датчиками на сервером.
Припускається, що є системи для для безпечного зберігання та аналізу даних готелів, хостелів та апартаментів на сервері.
Припускається, що ніхто з користувачів системи не буде мати доступу до зміни даних, які приходять з датчиків на сервер. Це збереже реальну ситуацію з використаними ресурсами, та дозволить прозоро розраховувати ціни за кімнати.
Залежності:

Залежність від надійності та точності датчиків сторонніх постачальників є важливим фактором. Якість і надійність цих датчиків безпосередньо впливають на точність зібраних даних та ефективність функціонування системи.



Залежність від стабільності мобільних мереж і доступу до Інтернету є критично важливою для безперебійної передачі даних з датчиків на сервер.
Залежність від постійного розвитку технологій, включаючи датчики, мобільні пристрої, програмне забезпечення та Інтернет, вимагає регулярного оновлення системи. Це необхідно для забезпечення сумісності з новими технологіями та задоволення змінюваних потреб користувачів.
Залежність від ефективних методів забезпечення конфіденційності та безпеки даних відвідувачів. Потрібно впровадити суворі заходи безпеки, щоб захистити дані від несанкціонованого доступу, розголошення та використання.



Рамки та обмеження проєкту
Рамки первинного випуску




Веб-інтерфейс:
Реєстрація та авторизація: медичний персонал пологових будинків матиме можливість реєструватися та авторизуватися в системі за допомогою веб- інтерфейсу.

Перегляд кількості використаних ресурсів: користувачі веб-інтерфейсу зможуть переглядати кількість використаних ресурсів в режимі реального часу, включаючи воду, світло та електроенергію.
Додавання кімнат в готелі: адміністратор системи матиме можливість додавати нові кімнати з новими датчиками до системи.
Відстеження динаміки використання ресурсів: менеджери та відвідувачі зможуть відстежувати динаміку використання енергоресурсів, щоб виявляти будь-які відхилення від норми, аби завчасно запобігти критичній ситуації.
Отримання сповіщень про критичну кількість використаних ресурсів: у випадку виявлення критичної кількості використаних ресурсів за короткий проміжок часу, що призводять до майбутніх критичних ситуацій або перевантаження мережі система автоматично сповістить персонал готелю через веб-інтерфейс.
Додавання нових відвідувачів: адміністратор готелю матиме можливість додавати нових відвідувачів до системи.
IoT-функціональність:
Підключення датчиків у кімнаті: датчики, встановлені в приміщеннях, будуть у режимі реального часу збирати дані про використання ресурсів та передавати їх до системи.
Автоматичне сповіщення: якщо буде виявлено критичну кількість використаних ресурсів за короткий час, що може призвести до майбутніх критичних ситуацій або перевантаження мережі, система автоматично сповістить персонал готелю через веб-інтерфейс, а відвідувачів – через мобільний додаток.

MF-1: Реєстрація та авторизація користувачів.
Завдяки зручній системі реєстрації та входу до системи, доступній як на веб-сайті, так і в мобільному додатку, користувачі можуть легко отримати доступ до своїх персональних даних та інформації про бронювання, використовуючи унікальний логін та пароль.
MF-2: Збір та моніторинг даних використаних ресурсів.
Завдяки веб-інтерфейсу та мобільному додатку користувачі отримують доступ до актуальних даних про стан новонароджених. Ці дані включають електрокардіограму, рівень насиченості киснем, температуру тіла та рівень рухової активності, які збираються датчиками. Це дає можливість медичному персоналу пологових будинків безперервно відстежувати стан новонароджених та негайно реагувати на будь-які ознаки проблем зі здоров'ям.
MF-3: Додавання кімнат до системи.
Функціонал адміністративного інтерфейсу дозволяє системному адміністратору додавати нові кімнати до системи та налаштовувати параметри датчиків для кожної кімнати, щоб забезпечити збір необхідних даних.
MF-4: Автоматичне сповіщення.

Веб-інтерфейс та мобільний додаток відіграють ключову роль у забезпеченні безперебійної роботи готелю, надаючи користувачам негайну інформацію про критичні зміни в показниках датчиків, що дозволяє адміністраторам готелів приймати своєчасні та ефективні рішення.
MF-5: Дані про використання ресурсів, що зберігаються в адміністративній панелі веб-сайту, будуть доступні користувачам через мобільний додаток та веб-інтерфейс.

Завдяки мобільному додатку та веб-інтерфейсу користувачі матимуть доступ до актуальної інформації про споживання енергоресурсів.




Рамки наступних випусків




Веб-інтерфейс:

Користувачі веб-інтерфейсу мають можливість відстежувати історію використання ресурсів, що дає їм глибоке розуміння ситуації та можливість приймати правильні рішення.
Завдяки веб-інтерфейсу адміністратори системи зможуть здійснювати централізоване управління датчиками в кімнаті. Це надасть їм можливість віддалено відстежувати стан датчиків, калібрувати їх та, у разі потреби, замінювати.
Веб-інтерфейс надає адміністраторам системи зручний канал для комунікації з користувачами з питань технічної підтримки.
MF-6: Управління датчиками в кімнатах.
Веб-інтерфейс надає адміністраторам системи централізований контроль над датчиками, які встановлені в кімнатах.

MF-7:	Віддалений	доступ	до	історії	використання	енергоресурсів	з можливістю її детального аналізу.
Веб-інтерфейс та мобільний додаток надають доступ до історії використання ресурсів для їх перегляду та аналізу.
MF-8: Надання технічної підтримки користувачам:
Система пропонує користувачам комплексний супровід: технічну підтримку та детальні інструкції з використання. Зв'язатися зі службою технічної підтримки можна через веб-інтерфейс або мобільний додаток.




Обмеження та винятки





Обмеження втрати зв'язку з датчиками розрахування: система розрахування ресурсів потребує постійного зв'язку з датчиками для збору та передачі даних про споживання. Переривання зв'язку може призвести до тимчасової втрати доступу до певних показників, що може спричинити затримку в отриманні інформації адміністратором. Це, в свою чергу, може призвести до виникнення критичних або аварійних ситуацій.
Обмеження неможливості вимірювання певних показників: існує проблема з вимірюванням певних аспектів використання ресурсів, таких як чистота повітря або споживання кисню, через обмеження доступних датчиків. Це може призвести до того, що система не матиме повної картини використання ресурсів у 22% випадків.

Залежність від Інтернету: система покладається на інтернет-з'єднання для роботи мобільного додатку та веб-інтерфейсу. Це означає, що без доступу до Інтернету користувачі не зможуть: віддалено відстежувати використання ресурсів, отримувати сповіщення про надмірне використання, керувати датчиками та налаштуваннями.




Бізнес-контекст
Профілі зацікавлених сторін



На таблиці 1.1 описані профілі зацікавлених сторін: Таблиця 1.1 – Профілі зацікавлених сторін проекту


Обмеження

Головний інтерес

Ставлення
Головна цінність

Зацікавлена сторона
Наявність доступу до мережі Інтернет або
Підвищення ефективності готельного персоналу та оптимізація
енергоспоживанн
Стійке, допоки продукт буде сумісний з
теперішньо
Швидкий доступ до готельної інформації
Готелі


я










електромере жі
в готелях
ю системою моніторингу




Доступність датчиків для розрахунк
у кількості використа них ресурсів
Зниження ризику виникнення критичних ситуацій з надмірним використанням ресурсів
Орієнтоване на зручність, позитивне
Вчасний та точний моніторинг використан ня ресурсів запобіжить критичним ситуаціям
Готельний персонал та відвідувачі
Доступ до Інтернету
Слідкування за кількістю використаних ресурсів
Позитивне, орієнтоване на зручність
Швидкий доступ до готельної
інформації
Відвіду вачі
Очікування ROI
(повернення інвестицій), ринкові ризики
Зростання ринку, перевага над конкурентами
Орієнтоване на прибуток
Фінансова віддача, зростання доходів, реінвестиції
Інвестори




Пріоритети проекту




На таблиці 1.2 наведені пріорітети проєкту:

Таблиця 1.2 – Пріоритети проекту

Ступінь свободи
(допустимий діапазон)
Обмеження (граничні значення)
Виконання (етапи)
Показник
Можливе відхилення від графіку на 1-2 місяці
Продукт має бути випущеним приблизно до 05.06.2024


Розклад/план робіт
100% функціоналу має працювати на релізі 1.0




Функціональн і сть
Допустиме відхилення на 10%
~42 000 гривень


Ціна


Максимальний розмір команди це 1 розробник та адміністратор


Персонал
100% всіх наявних даних з датчиків повинні бути вірними




Якість




Робоче середовище

Оскільки система буде обслуговувати користувачів з усього світу, забезпечення безперебійного доступу є критично важливим для її роботи. Хмарні сервіси Azure мають таку функціональність, їх й було використано.
Для розробки серверної частини системи було обрано мову програмування C# [1] та технологію ASP.NET [2] Web API. Цей вибір обумовлений тим, що в поєднанні C# та ASP.NET Web API забезпечують надійну, безпечну, швидку та масштабовану платформу для серверної частини системи. Це дозволить системі ефективно обслуговувати користувачів з усього світу.
Для зберігання даних системи було обрано базу даних MSSQL Server [3], завдяки швидкості, надійності, шифруванню даних та відповідності вимогам GDPR. Завдяки бібліотеці Entity Framework Core, яка є ORM, буде здійснено доступ до взаємодії з базою даних.
Для розробки IoT пристрою буде використано мову програмування C# та технологію AoT.
Для забезпечення конфіденційності буде використано протокол HTTPS, який шифрує дані під час їх передачі. Крім того, для авторизації та аутентифікації буде застосовуватися метод JWT, що додасть ще один рівень захисту.

ПОСТАНОВКА ЗАДАЧІ




Згідно з проведеним аналізом предметної області, метою курсової роботи є розробка програмної системи, що дозволяє моніторити та рахувати кількість використання енергоресурсів в готелях.
База даних повинна включати інформацію про: користувачів, апартаменти, бронювання, датчики, стан апартаментів, повідомлення.
Для відвідувача має бути реалізований наступний функціонал:
Реєстрація та авторизація до системи;
Перегляд і редагування своїх даних, таких як ім'я, прізвище та інформація про бронювання;
Доступ до інформації про кімнати;
Перегляд статистичних даних з датчиків в кімнатах.
Для адміністратора системи необхідно реалізувати такий функціонал:
Вхід в систему;
Редагування, створення, видалення та перегляд користувачів;
Редагування, створення, видалення та перегляд сенсорів;
Редагування, створення, видалення та перегляд налаштувань сенсорів;
Створення та імпорт резервних копій системи.
Програмна система має підтримувати локалізацію та інтернаціоналізацію, включаючи такі функції: таблиці символів, обчислення дати та часу, формати дати й часу, місцевий та універсальний час, метричні та імперські одиниці вимірювання, порядок сортування тексту, а також різні напрямки введення тексту.

ПРОЕКТУВАННЯ БАЗИ ДАНИХ
Побудова ER-діаграми




Для проектування бази даних було розроблено ER-модель даних (див. рис. 3.1). Вона складається з 6 таблиць: користувачі, апартаменти, бронювання, датчики, стан апартаментів, повідомлення.
Рисунок 3.1 – ER-діаграма проєкту На діаграмі можна побачити такі зв’язки:

− Користувач –> Повідомлення. Один до багатьох. Кожен користувач може мати багато повідомлень, але кожне повідомлення пов'язане лише з одним користувачем.
− Користувач –> Бронювання. Один до багатьох. Кожен користувач може мати багато бронювань, але кожне бронювання пов'язане лише з одним користувачем.
− Апартаменти –> Інформація з датчиків. Один до багатьох. Кожні апартаменти можуть мати багато записів з датчиків, але кожний запис з датчиків пов'язаний лише з одними апартаментами.
− Апартаменти –> Стан апартаментів. Один до багатьох. Кожні апартаменти можуть мати багато записів зі стану апартаментів, але кожний запис пов'язаний лише з одними апартаментами.
− Апартаменти –> Бронювання. Один до багатьох. Кожні апартаменти можуть мати багато бронювань, але кожне бронювання пов'язане лише з одними апартаментами.

Побудова логічної моделі бази даних на основі ER-діаграми




Отже, у логічній моделі бази даних будуть представлені такі сутності:
−	Користувачі (User);
−	Бронювання (Bookings);
−	Апартаменти (Apartments);
−	Вимірювання (Measurements);
−	Повідомлення (Notifications);
−	Стан житла (ApartmentsCondition);
Створимо таблицю користувачів (User). Вона буде містити у собі такі атрибути: Id (первинний ключ), Name, Email, PasswordHashed, PasswordSalt, Role.
Перевіряємо таблицю User на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.

Отже, таблиця відповідає першій, другій та третій нормальним формам.

Cтворимо таблицю Бронювань (Bookings). Вона буде містити у собі такі атрибути:	Id	(первинний	ключ),	UserId	(зовнішній	ключ	для	зв’язку
«один-до-багатьох» з таблицею User), ApartmentId (зовнішній ключ для зв’язку
«один-до-багатьох»	з	таблицею	Apartment),	StartingDate,	EndingDate, PriceForManagement, TotalPrice.

Перевіряємо таблицю Bookings на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.

Отже, таблиця відповідає першій, другій та третій нормальним формам.
Створимо таблицю апартаментів (Apartments). Вона буде містити у собі такі атрибути:	Id	(первинний	ключ),	ConditionId	(зовнішній	ключ	для	зв’язку
«один-до-багатьох» з таблицею ApartmentsCondition), Type, Capacity, StartingPrice Status.
Перевіримо таблицю Apartments на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.
Отже, таблиця відповідає першій, другій і третій нормальним формам.
Створимо таблицю вимірювань (Measurements). Вона буде містити у собі такі атрибути: Id (первинний ключ), ApartmentId (зовнішній ключ для зв’язку
«один-до-багатьох» з таблицею Apartments), Metric, Value, Timespan

Перевіримо таблицю Measurements на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.
Отже, таблиця відповідає першій, другій і третій нормальним формам.


Створимо таблицю повідомлень (Notification). Вона буде містити у собі такі атрибути:  Id  (первинний  ключ),  UserId  (зовнішній  ключ  для  зв’язку
«один-до-багатьох» з таблицею User), Message, IsRead.

Перевіримо таблицю Notification на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.

Отже, таблиця відповідає першій, другій і третій нормальним формам.
Створимо таблицю для зберігання стану житла (ApartmentsCondition). Вона буде містити у собі такі атрибути: Id (первинний ключ), MinTemperature, MaxTemperature, MaxWaterUsage, MaxElectricityUsage.
Перевіримо таблицю ApartmentsCondition на відповідність нормалізації:
всі атрибути є атомарними, тобто містять лише одне значення;
повторювані дані відсутні;
всі неключові атрибути залежать від первинного ключа.

Отже, таблиця відповідає першій, другій і третій нормальним формам.

За результатами проектування таблиць та зв’язків майбутньої бази даних, було отримано її логічну схему, яка задовольняє першій, другій і третій нормальним формам.
Оскільки всі таблиці в логічній схемі бази даних знаходяться в третій нормальній формі, можна зробити висновок, що база даних загалом відповідає третій нормальній формі.

АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
Архітектура серверної частини




Система EcoWatt пропонує інноваційний підхід до керування енергоспоживанням та моніторингу в готелях. Вона охоплює три групи користувачів з різними можливостями: відвідувачів, які можуть керувати налаштуваннями в своїх номерах через веб-інтерфейс або мобільний додаток; управлінців, які володіють розширеними функціями для відстеження енергоспоживання та оптимізації роботи готелю; та IoT-пристрої, що збирають дані про навколишнє середовище для покращення функціональності системи. EcoWatt допомагає готелям економити електроенергію, підвищувати комфорт гостей та покращувати ефективність управління.
Основними потребами клієнтів є: перегляд даних кімнати, збереження показників з датчиків кімнати, можливість аналізу даних кімнати, можливість виявити можливі критичні, можливість отримання сповіщення щодо зміни показників кімнати або її критичного стану, отримання статистики даних з датчиків, зміна своїх даних та даних кімнати.
Основними потребами адміністратора є: можливість перегляду та створення, редагування користувачів системи, можливість створення датчиків в системі, можливість налаштування датчиків в системі, можливість створення, редагування та видалення даних користувачів, можливість створення резервних копій даних системи та їхній імпорт в систему.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).



Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи

Для написання серверної частини системи було обрано мову програмування
C# з використанням технології ASP.NET Core Web API, дозволяючи писати зрозумілий та продуктивний код.
У якості бази даних використано MSSQL Server, до якої здійснюється доступ з серверного застосунку за допомогою технології Entity Framework Core, дуже зручної бібліотеки, яка дозволяє мати взаємодію з базою даних через об’єкти.
Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).














Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи

Для тестування та демонстрації роботи API використовується OpenApi
Swagger, зручний інструмент, що покращує якість і зручність розробки шляхом перегляду та тестування API. Для забезпечення безпеки даних та конфіденційності застосовується протокол HTTPS, який захищає дані під час їх передачі.
Для хешування паролів і створення токенів для авторизації використовується бібліотека System.Security.Cryptography та JWT (Json Web Tokens) для створення токенів, забезпечуючи надійний і безпечний механізм управління доступом користувачів. Принцип REST API застосовується для передачі та отримання даних.
Система використовує API контролери для маршрутизації запитів. Вони ділять програму на логічні компоненти, кожен з яких відповідає за обробку певних типів запитів або дій користувачів, що спрощує управління кодом і дозволяє легко розширювати функціональність.

Розроблений серверний застосунок побудований за принципами трьох- шарової архітектури, яка складається з: Domain, Services, Abstractionта Controllers.
В архітектуру також були додані інтерсептори, які перехоплюють запити, та можуть блокувати їх за потребою. Так, наприклад, у представленому додатку є інтерсептор AdminAuth, представлений у виді атребуту. Він не дозволяє звичайним користувачам отримати доступ до адміністраторських сторінок. Архітектура серверного застосунку представлена на діаграмі пакетів (див. рис. 4.3).


Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи

Приклади коду серверної частини наведено в додатку А. Таким чином, були визначені технології та архітектура серверної частини програмної системи.



Архітектура ІоТ-частини



IoT частина системи взаємодіє з двома типами користувачів: менеджери та користувачі. Пряма взаємодія з користувачами здійснюється через монітор, на який виводяться дані, зібрані сенсором, а також його межі та частота збору даних.
Взаємодію користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).
Рисунок 4.4 – Діаграма прецедентів ІоТ частини програмної системи

Щоб продемонструвати функціональні можливості IoT компонента системи, було вирішено написати програму на мові C#, оптимізовану для роботи з апаратними обмеженнями IoT пристроїв через компіляцію в режимі Native AoT. Програма використовує консольний інтерфейс (CLI) для виведення інформації і бібліотеку System.Net.Http для передачі даних у форматі JSON.
Ця програма призначена для тривалого виконання на сервері, де зберігається таблиця з ідентифікаторами для призначення IoT пристроям, що дозволяє безперервно записувати дані сенсорів протягом тривалого часу. Код програми легко переноситься на реальні IoT пристрої і написаний з мінімальною кількістю рядків для оптимізації під обмежені ресурси таких пристроїв.
Для розробки IoT компонента системи було обрано мову C# завдяки її CLR компоненту .NET 8, який здійснює компіляцію коду. Бібліотека System.Net.Http використовується для створення і відправки HTTP-запитів, а бібліотеки System.Text.Json та Newtonsoft.Json — для серіалізації та десеріалізації об'єктів. Для наочної демонстрації використаних технологій створено діаграму пакетів (див. рис. 4.5).

Рисунок 4.5 - Діаграма пакетів ІоТ частини програмної системи

Для запуску додатку потрібно налаштувати пристрій, увімкнути його та підключити до WiFi. Якщо пристрій новий, його необхідно зареєструвати в системі. Після реєстрації пристрій починає надсилати нові дані на сервер. На основі цієї взаємодії було створено діаграму послідовності (див. рис. 4.6).
Рисунок 4.6 – Діаграма взаємодії ІоТ частини програмної системи Також, було створено діаграму діяльності (див. рис. 4.7).



Рисунок 4.7 – Діаграма діяльності ІоТ частини програмної системи

Таким чином, за допомогою діаграм пакетів, станів та діяльності були
визначені основні технології та архітектура системи.
Приклади коду IoT-частини системи було наведено в додатку Б.1.

ОПИС ПРОГРАМНОЇ СИСТЕМИ
Виклик і завантаження




Щоб запустити програму, завантажте архів з кодом та розархівуйте його. Також необхідно встановити останню версію MSSQL Server з офіційного сайту, оскільки програма використовує це ядро.
Щоб налаштувати з’єднання програми з базою даних, потрібно створити файл	appsettings.json	у	директорії “apz-pzpi-21-1-liashenko-yevhen/Task2/apz-pzpi-21-1-liashenko-yevhen-task2/EcoWatt Server” і відредагувати його за допомогою будь-якого текстового редактора. У цьому файлі слід вказати інформацію для входу до бази даних в розділі “ConnectionStrings” на рисунку 5.1. Також необхідно вказати секретний ключ JWT, який буде використовуватися для підписання токенів, розділ “Jwt”.


Рисунок 5.1 – Налаштування системи у файлі appsettings.json
Далі потрібно запустити серверну та клієнтську частини системи. Для цього можна використовувати будь яку IDE, наприклад, JetBrains Rider, яку необхідно завантажити з офіційного сайту продукту.

Наступним кроком буде відкриття файлу EcoWattServer.sln у папці “apz-pzpi-21-1-liashenko-yevhen-task2”, а також натиснути “CTRL + F5”, щоб запустити проект не у режимі дебагу.
Запуск IoT частини здійснюється аналогічно до запуску серверної частини Необхідно	створити	файл	settings.json	у	директорії “apz-pzpi-21-1-liashenko-yevhen/Task3/apz-pzpi-21-1-liashenko-yevhen-task3/IoT” і відредагувати його за допомогою будь-якого текстового редактора. У файлі потрібно вказати вміст рядка, виділеного зеленим на рисунку 5.2, де слід зазначити посилання на хост серверної частини.

Рисунок 5.2 – Налаштування ІоТ-пристрою у файлі settings.json




Призначення і логічна структура



Функції, які може виконувати програма, можна розбити на декілька модулів,
а саме:
авторизація та реєстрація;
профіль;
кімнати;
дані системи;
користувачі системи;
датчики системи;
налаштування датчиків системи;

Модуль «Авторизація та реєстрація» включає функції для входу в систему та створення нового облікового запису. Реєстрація дозволяє користувачеві створити новий запис у базі даних, який використовується для входу в систему за допомогою логіну та пароля. Щоб увійти як адміністратор, необхідно спочатку створити обліковий запис адміністратора в базі даних.
Модуль «Профіль» забезпечує функції перегляду та редагування особистої інформації користувача, зокрема імені, прізвища та даних про контракт з готелем, тощо.
Модуль «Кімнати» містить у собі функціонал перегляду доступних кімнат, а також перегляд статистики даних з усіх датчиків, які знаходяться в неї.
Модуль «Дані системи» є адміністративним і включає функції експорту та імпорту даних системи.
Модуль «Користувачі системи» є адміністративним і забезпечує можливості додавання, редагування та видалення користувачів системи.
Модуль «Датчики системи» є адміністративним і надає функції додавання, редагування та видалення датчиків системи.
Модуль «Налаштування датчиків системи» є адміністративним і включає функції додавання, редагування та видалення налаштувань датчиків системи.

ВИСНОВКИ





В результаті виконаної роботи було створено програмну систему для раннього виявлення захворювань у новонароджених в пологовому будинку. Під час розробки було проведено аналіз предметної області, спроектовано базу даних, а також розроблено архітектуру серверної, IoT та клієнтської частин системи, які було реалізовано за допомогою ASP.NET Web API та Next.js.
Створена система дозволяє користувачам моніторити здоров'я своїх дітей. Вона надає функції реєстрації та авторизації, а також управління профілем. Користувачі можуть переглядати інформацію та статистику про стан здоров'я своїх дітей. Система забезпечує моніторинг стану здоров'я дитини в реальному часі і генерує сповіщення про зміни стану. Також є можливість адміністрування: адміністратор може керувати користувачами, датчиками, їх налаштуваннями, а також створювати і завантажувати резервні копії даних.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Бондарєв В.М. Об'єктно-орієнтоване програмування на С #. Навчальний посібник / В. М. Бондарєв. - Харків: СМІТ, 2009р. - 221 с. (дата звернення: 16.06.2024).
2. 	ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (дата звернення: 16.06.2024)
3.	MSSQL Server Documentation. URL: https://learn.microsoft.com/en-us/sql/?view=sql-server-ver16 (дата звернення: 27.06.2024)
4.	Azure IoT Hub Documentation. URL: https://learn.microsoft.com/en-us/azure/iot-hub/ (дата звернення: 27.06.2024)


ДОДАТОК А
Результат перевірки на плагіат

Рисунок А.1 – Результат перевірки на плагіат


ДОДАТОК Б
Програмний код серверної частини

	Б.1 Код основного файлу для роботи сервера Program.cs:
1. using System.Text;
2. using BLL.Apartment;
3. using BLL.BackUp;
4. using BLL.Bookings;
5. using BLL.Jwt;
6. using BLL.Measurements;
7. using BLL.Notifications;
8. using BLL.Statistics;
9. using BLL.Users;
10. using BLL.Validation;
11. using Core.Entities;
12. using DAL.Data;
13. using EcoWattServer.Filters;
14. using EcoWattServer.Migrations;
15. using Microsoft.AspNetCore.Authentication.JwtBearer;
16. using Microsoft.EntityFrameworkCore;
17. using Microsoft.IdentityModel.Tokens;
18. using Microsoft.OpenApi.Models;
19. 
20. var builder = WebApplication.CreateBuilder(args);
21. 
22. var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
23. 
24. builder.Services.AddDbContext<DataContext>(options =>
25.     options.UseSqlServer(connectionString,  b => b.MigrationsAssembly("EcoWattServer")));
26. 
27. //Adding Exception filter to the program
28. builder.Services.AddControllers(options =>
29. {
30.     options.Filters.Add<ExceptionFilter>();
31. });
32. 
33. // Add services to the container.
34. // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
35. builder.Services.AddEndpointsApiExplorer();
36. builder.Services.AddSwaggerGen(c =>
37. {
38.     c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
39.     {
40.         Description = "JWT Authorization header using the Bearer scheme. Example: \"Authorization: Bearer {token}\"",
41.         Name = "Authorization",
42.         In = ParameterLocation.Header,
43.         Type = SecuritySchemeType.ApiKey
44.     });
45. 
46.     c.AddSecurityRequirement(new OpenApiSecurityRequirement
47.     {
48.         {
49.             new OpenApiSecurityScheme
50.             {
51.                 Reference = new OpenApiReference
52.                 {
53.                     Type = ReferenceType.SecurityScheme,
54.                     Id = "Bearer"
55.                 }
56.             },
57.             new string[] { }
58.         }
59.     });
60. });
61. 
62. builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =>
63. {
64.     options.TokenValidationParameters = new TokenValidationParameters
65.     {
66.         ValidateIssuerSigningKey = true,
67.         ValidateLifetime = true,
68.         ValidateIssuer = false,
69.         ValidateAudience = false,
70.         IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8
71.             .GetBytes(builder.Configuration.GetSection("Jwt:SecretKey").Value)),
72.     };
73. });
74. 
75. builder.Services.AddCors();
76. builder.Services.AddScoped<IJwtTokenService, JwtTokenService>();
77. builder.Services.AddScoped<IPasswordService, PasswordService>();
78. builder.Services.AddScoped<IUserService, UserService>();
79. builder.Services.AddScoped<INotificationService, NotificationService>();
80. builder.Services.AddScoped<IMeasurementService, MeasurementService>();
81. builder.Services.AddScoped<IStatisticsService, StatisticsService>();
82. builder.Services.AddScoped<IBackUpService, BackUpService>();
83. builder.Services.AddScoped<IApartmentsService, ApartmentsService>();
84. builder.Services.AddScoped<IBookingService, BookingService>();
85. 
86. var app = builder.Build();
87. 
88. // Configure the HTTP request pipeline.
89. if (app.Environment.IsDevelopment())
90. {
91.     app.UseSwagger();
92.     app.UseSwaggerUI();
93. }
94. 
95. app.UseHttpsRedirection();
96. 
97. app.UseAuthentication();
98. app.UseAuthorization();
99. 
100. app.MapControllers();
101. app.UseMiddleware<JwtConnectorMiddleware>();
102. 
103. app.Run();

Б.2 Код сервісу для менеджменту апартаментів
1. public class ApartmentsService: IApartmentsService
2. {
3.     private readonly DataContext _dataContext;
4. 
5.     public ApartmentsService(DataContext dataContext)
6.     {
7.         _dataContext = dataContext;
8.     }
9.     
10.     public async Task<List<Apartments>> GetAllApartmentsAsync()
11.     {
12.         return await _dataContext.ApartmentsList.ToListAsync();
13.     }
14. 
15.     public async Task<Apartments?> GetApartmentsByIdAsync(int id)
16.     {
17.         var apartments = await _dataContext.ApartmentsList.FirstOrDefaultAsync(a => a.Id == id);
18. 
19.         if (apartments is null)
20.         {
21.             return null;
22.         }
23. 
24.         return apartments;
25.     }
26. 
27.     public async Task<Apartments> CreateApartmentsAsync(ApartmentCreateOrUpdateDto apartments)
28.     {
29.         var dbApartments = new Apartments()
30.         {
31.             Capacity = apartments.Capacity,
32.             Condition = apartments.Condition,
33.             Status = apartments.Status,
34.             Type = apartments.Type,
35.             StartingPrice = apartments.StartingPrice,
36.         };
37.         
38.         _dataContext.ApartmentsList.Add(dbApartments);
39.         await _dataContext.SaveChangesAsync();
40. 
41.         return dbApartments;
42.     }
43. 
44.     public async Task<IModel> UpdateApartmentsAsync(int id, ApartmentCreateOrUpdateDto apartments)
45.     {
46.         var dbApartments = await _dataContext.ApartmentsList.FirstOrDefaultAsync(a => a.Id == id);
47. 
48.         if (dbApartments is null)
49.         {
50.             return new ErrorDto()
51.             {
52.                 Message = $"Apartments with id: {id} was not found",
53.             };
54.         }
55. 
56.         dbApartments.Capacity = apartments.Capacity;
57.         dbApartments.StartingPrice = apartments.StartingPrice;
58.         dbApartments.Condition = apartments.Condition;
59.         dbApartments.Status = apartments.Status;
60.         dbApartments.Type = apartments.Type;
61. 
62.         _dataContext.ApartmentsList.Update(dbApartments);
63.         await _dataContext.SaveChangesAsync();
64. 
65.         return apartments;
66.     }
67. 
68.     public async Task<IModel> DeleteApartmentsAsync(int id)
69.     {
70.         var apartments = await _dataContext.ApartmentsList.FirstOrDefaultAsync(aa => aa.Id == id);
71. 
72.         if (apartments is null)
73.         {
74.             return new ErrorDto()
75.             {
76.                 Message = $"Apartments with id: {id} was not found",
77.             };
78.         }
79.         
80.         _dataContext.ApartmentsList.Remove(apartments);
81.         await _dataContext.SaveChangesAsync();
82. 
83.         return new SuccessDto()
84.         {
85.             Message = "Apartments was successfully deleted."
86.         };
87.     }
88. 
89.     public async Task<List<Apartments>> GetApartmentsByStatusAsync(Availability status)
90.     {
91.         var apartments = await _dataContext.ApartmentsList
92.             .Where(a => a.Status == status)
93.             .ToListAsync();
94. 
95.         return apartments;
96.     }
97. }

Б.3 Код сервісу для аутентифікації
1. public class JwtTokenService: IJwtTokenService
2. {
3.     public IConfiguration Configuration { get; set; }
4. 
5.     public JwtTokenService(IConfiguration configuration)
6.     {
7.         Configuration = configuration;
8.     }
9. 
10.     public string GenerateToken(int userId, RoleEnum role)
11.     {
12.         var userClaims = new List<Claim>
13.         {
14.             new Claim(ClaimTypes.NameIdentifier, userId.ToString()),
15.             new Claim(ClaimTypes.Role, role.ToString())
16.         };
17. 
18.         var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration.GetSection("Jwt:SecretKey").Value));
19.         var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha512Signature);
20.         var token = new JwtSecurityToken(
21.             claims: userClaims,
22.             expires: DateTime.Now.AddDays(1),
23.             signingCredentials: credentials);
24. 
25.         var jwt = new JwtSecurityTokenHandler().WriteToken(token);
26.         return jwt;
27.     }
28. }

Б.4 Код сервісу для створення резервної копії
1. public class BackUpService : IBackUpService
2. {
3.     private readonly DataContext _context;
4. 
5.     public BackUpService(DataContext context)
6.     {
7.         _context = context;
8.     }
9. 
10.     public async Task SaveToCsv(string directoryPath)
11.     {
12.         Directory.CreateDirectory(directoryPath);
13.         var entityTypes = _context.Model.GetEntityTypes();
14. 
15.         foreach (var entityType in entityTypes)
16.         {
17.             var entityName = entityType.ClrType.Name;
18.             var filePath = Path.Combine(directoryPath, $"{entityName}.csv");
19. 
20.             var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
21.             if (dbSetProperty == null) continue;
22. 
23.             var dbSet = dbSetProperty.GetValue(_context);
24.             var queryable = dbSet as IQueryable<object>;
25.             if (queryable == null) return;
26. 
27.             var entities = await queryable.ToListAsync();
28. 
29.             using var writer = new StreamWriter(filePath);
30.             using var csv = new CsvWriter(writer, CultureInfo.InvariantCulture);
31.             await csv.WriteRecordsAsync(entities);
32.         }
33.     }
34. 
35.     public async Task RestoreFromCsv(string directoryPath)
36.     {
37.         var entityTypes = _context.Model.GetEntityTypes();
38. 
39.         foreach (var entityType in entityTypes)
40.         {
41.             var entityName = entityType.ClrType.Name;
42.             var filePath = Path.Combine(directoryPath, $"{entityName}.csv");
43. 
44.             if (!File.Exists(filePath)) continue;
45. 
46.             var dbSetProperty = _context.GetType().GetProperty(entityName + "s");
47.             if (dbSetProperty == null) continue;
48. 
49.             var dbSet = dbSetProperty.GetValue(_context);
50. 
51.             using var reader = new StreamReader(filePath);
52.             using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
53. 
54.             var entityListType = typeof(List<>).MakeGenericType(entityType.ClrType);
55.             var entities = (IList)Activator.CreateInstance(entityListType);
56. 
57.             var records = csv.GetRecords(entityType.ClrType);
58.             foreach (var record in records)
59.             {
60.                 entities.Add(record);
61.             }
62.             
63.             var addRangeMethod = dbSet.GetType().GetMethod("AddRange", new[]
64.             {
65.                 typeof(IEnumerable<>).MakeGenericType(entityType.ClrType)
66.             });
67.             
68.             if (addRangeMethod != null)
69.             {
70.                 addRangeMethod.Invoke(dbSet, new object[] { entities });
71.             }
72.             
73.             await _context.SaveChangesAsync();
74.         }
75.     }
76. 
77.     public async Task<byte[]> DownloadAsZip(string directoryPath)
78.     {
79.         await SaveToCsv(directoryPath);
80. 
81.         using var memoryStream = new MemoryStream();
82.         using (var zipOutputStream = new ZipOutputStream(memoryStream))
83.         {
84.             zipOutputStream.SetLevel(3);
85. 
86.             var csvFiles = Directory.GetFiles(directoryPath, "*.csv");
87.             foreach (var filePath in csvFiles)
88.             {
89.                 var entry = new ZipEntry(Path.GetFileName(filePath))
90.                 {
91.                     DateTime = DateTime.Now,
92.                     IsUnicodeText = true
93.                 };
94.                 zipOutputStream.PutNextEntry(entry);
95. 
96.                 using var fileStream = File.OpenRead(filePath);
97.                 fileStream.CopyTo(zipOutputStream);
98.                 zipOutputStream.CloseEntry();
99.             }
100.         }
101. 
102.         return memoryStream.ToArray();
103.     }
104. }


ДОДАТОК В
Програмний код ІоТ пристрою
	В.1 Стартовий файл програми
1. using System.Net.Http.Headers;
2. using System.Text;
3. using IoTEcoWatt.Entities;
4. using Microsoft.Extensions.Configuration;
5. using Newtonsoft.Json;
6. 
7. // Без цього ми не побачимо українськи символи
8. Console.OutputEncoding = Encoding.UTF8;
9. 
10. // Завантаження конфігурації з файлу appsettings.json
11. var builder = new ConfigurationBuilder();
12. builder.SetBasePath(Directory.GetCurrentDirectory())
13.     .AddJsonFile("appsettings.json", optional: false);
14. IConfiguration configBuilder = builder.Build();
15. var configuration = new Configuration();
16. configBuilder.Bind(configuration);
17. 
18. Console.WriteLine("Ласкаво просимо до системи EcoWatt!");
19. 
20. // Аутентифікація та отримання JWT
21. 
22. 
23. using var client = new HttpClient();
24. var loginData = new
25. {
26.     email = configuration.Credentials.Email,
27.     password = configuration.Credentials.Password,
28. };
29. 
30. var loginContent = new StringContent(JsonConvert.SerializeObject(loginData), Encoding.UTF8, "application/json");
31. var loginResponse = await client.PostAsync($"{configuration.ApiUrl}/User/Login", loginContent);
32. 
33. if (!loginResponse.IsSuccessStatusCode)
34. {
35.     Console.WriteLine($"Помилка: {loginResponse.StatusCode} - Неможливо увійти.");
36.     return;
37. }
38. 
39. var jwt = await loginResponse.Content.ReadAsStringAsync();
40. client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", jwt);
41. 
42. Console.WriteLine("Перевірка даних користувача");
43. for (int i = 0; i < 3; i++)
44. {
45.     Console.WriteLine("...");
46.     await Task.Delay(1000);
47. }
48. 
49. try
50. {
51.     // Отримання даних користувача
52.     var userResponse = await client.GetAsync($"{configuration.ApiUrl}/User/{1}");
53. 
54.     // Перевірка чи користувача не знайдено
55.     if (!userResponse.IsSuccessStatusCode)
56.     {
57.         Console.WriteLine($"Помилка: {userResponse.StatusCode} - Неможливо знайти користувача.");
58.         return;
59.     }
60.     
61.     var userResponseBody = await userResponse.Content.ReadAsStringAsync();
62.     var user = JsonConvert.DeserializeObject<User>(userResponseBody);
63. 
64.     Console.WriteLine($"Привіт, {user.Name}!");
65. 
66.     Console.WriteLine("Отримання даних вашого номеру...");
67.     for (int i = 0; i < 2; i++)
68.     {
69.         Console.WriteLine("...");
70.         await Task.Delay(1000);
71.     }
72.     
73.     var response = await client.GetAsync($"{configuration.ApiUrl}/Apartments/{1}");
74.     
75.     if (!response.IsSuccessStatusCode)
76.     {
77.         Console.WriteLine($"Помилка: {response.StatusCode} - {await response.Content.ReadAsStringAsync()}");
78.         return;
79.     }
80.     
81.     Console.WriteLine("Отримання даних з датчиків вашого номеру...");
82.     for (int i = 0; i < 2; i++)
83.     {
84.         Console.WriteLine("...");
85.         await Task.Delay(1000);
86.     }
87.     
88.     var response_iot = await client.GetAsync($"{configuration.ApiUrl}/Measurement");
89.     
90.     if (!response_iot.IsSuccessStatusCode)
91.     {
92.         Console.WriteLine($"Помилка: {response_iot.StatusCode} - {await response_iot.Content.ReadAsStringAsync()}");
93.         return;
94.     }
95. 
96.     var responseBody = await response_iot.Content.ReadAsStringAsync();
97.     var measurements = JsonConvert.DeserializeObject<Measurement[]>(responseBody)!;
98.     
99.     Console.WriteLine("Дані успішно отримано:");
100.     
101.     foreach (var measurement in measurements)
102.     {
103.         Console.WriteLine($"Показник датчику: {measurement.Metrics}");
104.         Console.WriteLine($"Значення виміру: {measurement.Value}");
105.         Console.WriteLine($"Дата виміру: {measurement.TimeSpan}");
106.         Console.WriteLine("-------------------");
107.     }
108.     Console.WriteLine("Хай щастить!");
109. }
110. catch (Exception ex)
111. {
112.     // Відображення будь-якої виняткової ситуації, яка може виникнути
113.     Console.WriteLine($"Виникла несподівана помилка: {ex.Message}");
114. }


